<!DOCTYPE html>
<html>
  <head>
    <title>FileSystem API</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "filesystem-api",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://w3c.github.io/filesystem-api/Overview.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Arun Ranganathan", url: "http://arunranga.com",
                company: "Mozilla", companyURL: "http://www.mozilla.org/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "Web Applications Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2008/webapps/",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-webapps",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
         wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      .example .example .example-title {
          display: none
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>The FileSystem API defines functionality on a local sandboxed file system within the same origin of the Web Application that created it. It exposes standard file system operations to Web Applications, such as creation of files and directories, and reading, writing, and copying files and directories.  It builds on top of the [[!FileAPI]] and uses Promises for asynchronous functionality [[!ECMAScript]].</p>
    </section>
    <section id="sotd">
      Portions of this specification are in flux, and are likely to be re-written; where appropriate, these have been marked as ISSUES by the editor. Implementors are encouraged to contribute to discussions on the <a href="http://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a> mailing list. This work uses the "<a href="http://dev.w3.org/2009/dap/file-system/file-dir-sys.html">File API: Directories and System</a>" W3C Note as a starting point.
    </section>
    
    <section id='introduction' class='informative'>
      <h2>Introduction</h2>
      <p>The FileSystem API is for Web applications that have client-side storage needs not readily addressed by database APIs such as [[IndexedDB]].   Such applications need to handle common file types that end users typically link with logical directory structures in a file system, and generally involve binary data that may be shared with other applications.  The API is designed to be asynchronous using Promises [[!ECMAScript]].</p>
      <p>The FileSystem API is a virtual file system, and thus user agents are responsible for allocating space for the creation of a sandboxed file system and for imposing storage quotas on that virtual file system.  </p>
    
    <section id="useCases">
      <h3>Use Cases</h3>

      <ol>
          <li>Persistent uploader
            <ul>
            <li>When a file or directory is selected for upload, it copies it
            into a local sandbox and uploads a chunk at a time.</li>
            <li>It can restart uploads after browser crashes, network
            interruptions, etc.</li>
            </ul>
          </li>
          <li>Video game or other app with lots of media assets
            <ul>
            <li>It downloads one or several large tarballs, and expands them
            locally into a directory structure.</li>
            <li>The same download should work on any operating system.</li>
            <li>It can manage prefetching just the next-to-be-needed assets in
            the background, so going to the next game level or activating a new
            feature doesn't require waiting for a download.</li>
            <li>It uses those assets directly from its local cache, by direct
            file reads or by handing local URLs to image or video tags, WebGL
            asset loaders, etc.</li>
            <li>The files may be of arbitrary binary format.</li>
            </ul>
          </li>

          <li>Audio/Photo editor with offline access or local cache for speed
            <ul>
            <li>Data here is potentially quite large, and is
            read-write.</li>
            <li>It may want to do partial writes to files (ovewriting just the
            ID3/EXIF tags, for example).</li>
            <li>The ability to organize project files by creating directories
            would be useful.</li>
            
            </ul>
          </li>

          <li>Offline video viewer
            <ul>
            <li>It downloads large files (&gt;1GB) for later viewing.</li>
            <li>It needs efficient seek + streaming.
             </li>
            <li>It must be able to hand a URL to the video tag.</li>
            <li>It should enable access to partly-downloaded files e.g.  to let
            you watch the first episode of the DVD even if your download didn't
            complete before you got on the plane.</li>
            <li>It should be able to pull a single episode out of the middle of
            a download and give just that to the video tag; this can be accomplished by a URL scheme that works with a filesystem path.</li>
            </ul>
          </li>

          <li>Offline Web Mail Client
            <ul>
            <li>Downloads attachments and stores them locally.</li>
            <li>Caches user-selected attachments for later upload.</li>
            <li>Needs to be able to refer to cached attachments and image
            thumbnails for display and upload.</li>
            <li>Should be able to trigger the UA's download manager just as if
            talking to a server.</li>
            <li>Should be able to upload an email with attachments as a
            multipart post, rather than sending a file at a time in an XHR.</li>
            </ul>
          </li>
        </ol>
    </section>
    
  </section>
  <section>
  <h2>Conformance</h2>

        <p>
          Everything in this specification is normative except for
          examples and sections marked as being informative.
        </p>
        <p>
          The keywords “MUST”, <br/>
          “MUST NOT”,<br/>
          “REQUIRED”,<br/>
          “SHALL”,<br/>
          “SHALL NOT”,<br/>
          “RECOMMENDED”,<br/>
          “MAY” and<br/>
          “OPTIONAL” in this document are to be
          interpreted as described in<br/>
          <cite><a href="http://www.ietf.org/rfc/rfc2119">Key words for use in RFCs to
              Indicate Requirement Levels</a></cite>
          [[!RFC2119]].
        </p>
        <p>
          The following conformance classes are defined by this specification:
        </p>
        <dl>
          <dt><dfn id="dfn-conforming-implementation">conforming user agent</dfn></dt>
          <dd>
            <p>
              A user agent is considered to be a
              <a>conforming user agent</a>
              if it satisfies all of the MUST-,
              REQUIRED- and SHALL-level
              criteria in this specification that apply to implementations.  This specification uses both the terms "conforming user agent" and "user agent" to refer to this product class.
            </p>
      <p>User agents may implement algorithms in this specifications in any way desired, so long as the end result is indistinguishable from the result that would be obtained
      from the specification's algorithms.</p>
          </dd>         
        </dl>
  <p>User agents that use ECMAScript to implement the APIs defined in this specification must implement them in a manner consistent with the
  ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]] as this specification uses that specification and terminology. </p>   

  </section>
  <section id="terminology">
    <h2>Terminology</h2>
    <p>The terms <dfn id="Blob">Blob</dfn>, <dfn id="File">File</dfn>, <dfn>Unix Epoch</dfn>, and <dfn>File Constructor Steps</dfn> are as defined by the [[!FileAPI]] specification.</p>
    <p>The terms <dfn id="scheme">scheme</dfn>, <dfn id="scheme-data">scheme data</dfn>, and <dfn id="URL">URL</dfn> are as defined by the [[!URL]] specification.</p>
    <p>The term <dfn id="origin">origin</dfn> is used as defined by the Web Origin Specification [[!ORIGIN]].</p>
    <p>The term <dfn id="worker"><code>worker</code></dfn> is defined by the WebWorkers specification [[!WEBWORKERS]].</p>
    <p>The terms <dfn>context object</dfn>, <dfn id="strictly-split-a-string">strictly split a string</dfn>, and <dfn id="document"><code>document</code></dfn> are defined by the HTML specification [[!HTML]].</p>

</section>
<section>
  <h2>Model</h2>
  <section>
    <h3>Directory, File, Root, and Path</h3>
  <p>A <dfn id="directoryConcept">directory</dfn> is a logical organizing storage unit with a distinct <dfn>name</dfn> which contains files and/or one or more <dfn id="subdirectoryConcept">subdirectory</dfn> units (which are themselves <a href="#directoryConcept">directory</a> units). The <a href="#directoryConcept">directory</a> is organized by a hierarchical containment structure, which can also be represented by a string, called a <dfn>path</dfn>; the <a>path</a> string uses the U+002F SOLIDUS character ("/") to denote directories within the <a>Directory Tree</a>. A file in this specification is as defined in the [[!FileAPI]], and is represented by a <code>File</code> object. Files, like directories, have distinct <a>name</a>s which identify them on the <a>Directory Tree</a>.</p>
    <p> The top-most containing <a href="#directoryConcept">directory</a>, which contains all <a href="#directoryConcept">directories</a> and files, if any exist, is called the <dfn>root</dfn> <a href="#directoryConcept">directory</a>, and has the following properties:</p> 
    <ul>
      <li>It is not contained by any other <a href="#directoryConcept">directory</a> in the <a>Directory Tree</a>; it contains all others.</li>
      <li>It is represented by a <a>path</a> that is equal to the string "/" (a single U+002F SOLIDUS character).</li>
      <li><p>It has the name "root" (that is, the Unicode characters U+0072, U+006F, U+006F, U=0074).</p>
      <div class="issue"><p>"root" is not intended to be a reserved word. Other subdirectories can be created that are called "root."</p></div>
      </li>
    </ul>
    <p>Each <a>origin</a> has one <a>root</a> <a href="#directoryConcept">directory</a>.</p>
  </section>
  <section>
    <h3>The Directory Tree</h3>
     <p>User agents must maintain an internal per-<a>origin</a> <dfn>Directory Tree</dfn> of <a href="#directoryConcept">directories</a> and files, along with the affiliated <a>path from root</a> for each <a href="#directoryConcept">directory</a> and file; each <a href="#directoryConcept">directory</a> or file must correspond to a node in the <a>Directory Tree</a>, with the <a>root</a> <a href="#directoryConcept">directory</a> being the <em>root</em> of the <a>Directory Tree</a>. </p>
     <div class="note"><p>The corollary to this is that for each file or <a href="#directoryConcept">directory</a>, user agents are required to maintain the position of that file or <a href="#directoryConcept">directory</a> on the <a>Directory Tree</a>.</p></div> 
     <p>A <dfn>Directory Pointer</dfn> is a pointer to a position in the <a>Directory Tree</a>; unless specified otherwise, it initally points to the <a>root</a> of the <a>Directory Tree</a>.</p>
    <p>The <dfn>present working directory</dfn> is the node on the <a>Directory Tree</a> that represents the current <a href="#directoryConcept">directory</a> from which an operation is taking place. In this specification, this is the <a>context object</a> from which a <a><code>Directory</code></a> operation is called. </p>
    <p>A <a>path</a> to a given <a href="#directoryConcept">directory</a> from the <a>root</a> <a href="#directoryConcept">directory</a> is said to be a <dfn>path from root</dfn> and always begins with a leading U+002F SOLIDUS ("/"). A <a>path</a> that is relative only from the <a>present working directory</a> is said to be a <dfn>relative path</dfn>, and does not begin with a U+002F SOLIDUS ("/").</p>
    <div class="note"><p>The <a>present working directory</a> may also be the <a>root</a> <a>Directory</a>, in which case the <a>path</a> does not need to begin with a leading U+002F SOLIDUS ("/"). If the <a>present working Directory</a> is the <a>root</a> <a href="#directoryConcept">directory</a>, then all <a>path</a>s to other directories or files can be represented by <a>relative path</a>s. </div>
      <pre class="example highlight">
var path = "/music/genres/jazz"; // path from root to jazz Directory

// set genres directory to the present working Directory:

var pathToJazz = "jazz"; // relative path from within genres to jazz Directory </pre>
<div class="issue"><p>Should additional definition be added to allow for "../.../myDir/yourDir" style path navigation under relative paths? Currently, we only allow <em>forward</em> path navigation; allowing "../../" will allow <em>backward</em> path navigation.</p></div>
<p>A <dfn>child</dfn> is a node on the <a>Directory Tree</a> with a position that is below a given position on the <a>Directory Tree</a> for a given <a href="#directoryConcept">directory</a>; a <a href="#subdirectoryConcept">subdirectory</a> of the <a>present working directory</a> is a <a>child</a> of the <a>present working directory</a>; a <a href="#subdirectoryConcept">subdirectory</a> of <em>that</em> <a href="#subdirectoryConcept">subdirectory</a> is also a <a>child</a> of the <a>present working directory</a>. An <dfn>immediate child</dfn> corresponds to a node on the <a>Directory Tree</a> that is either a <a href="#subdirectoryConcept">subdirectory</a> that is the next position on the <a>path</a>, or a file that is next on the <a>path</a>. A <dfn>parent</dfn> is a <a href="#directoryConcept">directory</a> that contains a file or another <a href="#directoryConcept">directory</a>; in particular, the <a href="#directoryConcept">directory</a> that contains the <a>present working directory</a> is its <a>parent</a>. The <a>root</a> <a href="#directoryConcept">directory</a> is the <a>parent</a> of all other nodes in the <a>Directory Tree</a>.</p>
<p>When this specification says to <dfn id="addToDirectoryTree">add d to the Directory Tree</dfn>, where <var>d</var> is either a file or a <a href="#directoryConcept">directory</a>, a user agent must add <var>d</var> to the <a>Directory Tree</a>, along with its <a>path from root</a>.</p>
<div class="note"><p>Adding to the <a>Directory Tree</a> involves allocating storage for a <em>new</em> <a href="#directoryConcept">directory</a> or a file, but not necessarily allocating storage for a pre-existing one, which can be added to the <a>Directory Tree</a> through a <a href="#transfer">transfer</a> operation. Failure to allocate storage owing to disk quota issues causes promises in this specification to get rejected with a <code>QuotaExceededError</code>.</p></div>
<p>When this specification says to <dfn id="removeFromDirectoryTree">remove d from the Directory Tree</dfn>, where <var>d</var> is either a file or a <a href="#directoryConcept">directory</a>, a user agent must remove <var>d</var> from the <a>Directory Tree</a>; in particular, this <a href="#removeThePath">removes the path</a> that <var>d</var> had and removes data associated with <var>d</var>. If <var>d</var> has files or <a href="#subdirectoryConcept">subdirectories</a> these must also be recursively removed, including the storage affiliated with each <a>child</a>.</p>
<div class="note"><p>User agents should determine if the storage can be reallocated for subsequent operations.</p></div>
<p>When this specification says to <dfn id="removeThePath">remove the path</dfn> for a particular node, which is either a file or a <a href="#directoryConcept">directory</a>, a user agent must remove the <a>path from root</a> for that node, without removing the storage allocated to that node or removing its data. This includes recursively removing the <a>path from root</a> for any <a>child</a> of that node, which applies only to <a href="#directoryConcept">directories</a>. </p> 
<p>When this specification says to <dfn id="transfer">transfer e to directory d</dfn>, where <var>e</var> is either a file or a <a href="#directoryConcept">directory</a>, the following steps must be followed, taking care to check for <a>illegal transfers</a>:</p>
  <ol>
    <li><p><a href="#removeThePath">Remove the path</a> for <var>e</var>.</p></li>
    <li><p>If there is already a file or <a href="#directoryConcept">directory</a> <var>o</var> with the identical name as <var>e</var> in <var>d</var>, run the following substeps:  </p>
    <ol>
      <li><p><a href="#removeFromDirectoryTree">Remove o from the Directory Tree</a>.</p>
      <div class="note"><p>This includes recursively removing any <a>child</a> nodes of <var>o</var>.</p></div>  
      </li>
      <li><p><a href="#addToDirectoryTree">Add e to the Directory Tree</a> such that <var>e</var> is an <a>immediate child</a> of <var>d</var>. If <var>e</var> is <a href="#directoryConcept">directory</a>, it becomes a <a href="#subdirectoryConcept">subdirectory</a> of <var>d</var>. If <var>e</var> is a file, it becomes a file contained by <var>d</var>.</p></li>
    </ol>  
    </li>
    <li><p>If <var>e</var> and <var>d</var> are identical, then terminate this algorithm, unless it is a <a href="#renamingOperation">renaming operation</a>.</p></li>
    <li><p>Otherwise <a href="#addToDirectoryTree">add e to the Directory Tree</a> such that <var>e</var> is an <a>immediate child</a> of <var>d</var>. If <var>e</var> is <a href="#directoryConcept">directory</a>, it becomes a <a href="#subdirectoryConcept">subdirectory</a> of <var>d</var>. If <var>e</var> is a file, it becomes a file contained by <var>d</var>.</p></li>
  </ol>
<div class="note"><p>Like <a href="#addToDirectoryTree">adding to the Directory Tree</a>, a <a href="#transfer">transfer</a> may generate storage quota errors.</p></div>
<p>The set of <dfn id="illegal">illegal transfers</dfn> which methods invoking the <a href="#transfer">transfer</a> algorithm must prevent are:</p>
<ul>
<li>A <a>parent</a> must never be <a href="#transfer">transferred</a> to a child.</li>
<li>A <a href="#directoryConcept">directory</a> must never be transferred to itself, unless it is a <a href="#renamingOperation">renaming operation</a>.</li>
<li>A <a>child</a> <var>a</var> of <var>b</var> can never be transferred to the <a>parent</a> of <var>b</var> if it has the same name as <var>b</var>. </li>
</ul>
<div class="issue"><p>TODO: See if there is a cohesive algorithm which results in better promise rejection messages for the <code>move</code> operation.</p></div>
<p>When this specification says to do a <dfn id="#renamingOperation">renaming operation</dfn> with a <em>new</em> <a>name</a> on a node <var>e</var> on the <a>Directory Tree</a>, where <var>e</var> is either a file or a <a href="#directoryConcept">directory</a>, user agents must change the <a>name</a> of <var>e</var> to the <em>new</em> <a>name</a>. If a <a href="#transfer">transfer</a> is invoked on two nodes, <var>e</var> and <var>d</var>, that identify the same node on the <a>Directory Tree</a>, unless <var>d</var> is supplied with a new <a>name</a>, the transfer is considered an <a href="#illegal">illegal transfer</a>. If the method invoking the <a href="#transfer">transfer</a> is supplied a new <a>name</a>, then it can perform a <a href="#renamingOperation">renaming operation</a>.</p>
<div class="note"><p>The change to the underlying model's node <var>e</var> will result in a new object, or invalidate existing <a><code>File</code></a> and <a><code>Directory</code></a> objects referring to the underlying resource with the old <a>name</a>, which no longer exists. </p></div>
<p>When this specification says to <dfn id="crawl-the-entire-path">crawl the entire path</dfn> for a given <a>path</a> <var>p</var>, the following steps must be run:</p>
<ol>
  <li><p>Let <var>input</var> be set to <a>path</a>, <var>position</var> be a pointer to <var>input</var>, initially set to the first character of <var>input</var>, and <var>tokens</var> be a list of tokens, initially empty. If <var>input</var> is a single U+002F SOLIDUS character, set the <a>Directory Pointer</a> to the <a>root</a> <a href="#directoryConcept">directory</a></a> and terminate this algorithm.</p></li>
  <li><p>If the character at <var>position</var> is a U+002F SOLIDUS character ("/"), set the <a>Directory Pointer</a> to <a>root</a>; this represents a <a>path from root</a>. Otherwise, set it to the <a>present working directory</a>. <a href="#strictly-split-a-string">Strictly split</a> <var>input</var> on the U+002F SOLIDUS character. </p></li>
  <li><p>For each token in <var>tokens</var>, if the next position of the <a>Directory Pointer</a> strictly matches the <a>name</a> of a <a href="#directoryConcept">directory</a> or a file, advance the <a>Directory Pointer</a> to that <a href="#directoryConcept">directory</a> or file. If it does not strictly match, return failure.</p></li>

</ol>
<p>When this specification says to <dfn id="crawl-the-path-until-node-n">crawl the path until node n</dfn> for a given <a>path</a> <var>p</var> and value for <var>n</var>, the following steps must be run:</p>
<ol>
  <li><p>Let <var>input</var> be set to <a>path</a>, <var>position</var> be a pointer to <var>input</var>, initially set to the first character of <var>input</var>, and <var>tokens</var> be a list of tokens, initially empty. If <var>input</var> is a single U+002F SOLIDUS character, set the <a>Directory Pointer</a> to the <a>root</a> <a href="#directoryConcept">directory</a></a> and terminate this algorithm.</p></li>
  <li><p>If the character at <var>position</var> is a U+002F SOLIDUS character ("/"), set the <a>Directory Pointer</a> to <a>root</a>; this represents a <a>path from root</a>. Otherwise, set it to the <a>present working directory</a>. <a href="#strictly-split-a-string">Strictly split</a> <var>input</var> on the U+002F SOLIDUS character. </p></li>
  <li><p>If n ≥ the number of tokens in <var>tokens</var>, run the <a>crawl the entire path</a> algorithm and terminate this algorithm.</p></li>
  <li>Otherwise, for each token in <var>tokens</var> up to the nth token, if the next position of the <a>Directory Pointer</a> strictly matches the <a>name</a> of a <a href="#directoryConcept">directory</a>, advance the <a>Directory Pointer</a> to that <a href="#directoryConcept">directory</a>. If it does not strictly match, return failure.</p></li>

</ol>

</section>
    
</section>
  <section>
    <h2>Extensions to Existing Objects</h2>
    <p>The FileSystem API is exposed to the Web via an extension to the <code>window.navigator</code> object [[!HTML]].  A URL-generating method for individual files within the virtualized filesystem is generated via an extension to the <code>window.URL</code> object [[!URL]].</p>
    <section id="extensionNav">
      <h3>Extension to Navigator</h3>
    <dl title='partial interface Navigator' class='idl'>
      <dt>Promise&lt;Directory?> getFileSystem()</dt>
  <dd>
    <p>The <code>getFileSystem</code> method returns a <code>Promise</code> that is either fulfilled with the <a>root</a> <a><code>Directory</code></a> object or fulfilled with <code>null</code> if the <a>root</a> <a><code>Directory</code></a> object cannot be returned. The <code>getFileSystem</code> method must act as follows:</p>
    <ol>
      <li><p>Let <var>promise</var> be a new promise and run the next steps asynchronously.</p></li>
      <li><p>Resolve or reject <var>promise</var> according to the <a>Directory Creation Steps</a> with no value given for <a>path</a>.</p>
  </li>
  <li>Return <var>promise</var>.</li>

  </ol>
  </dd>
</dl>
</section>
<section id="extensionURL">
  <h3>Extension to URL</h3>
  <dl title='partial interface URL' class='idl'>
  <dt>static DOMString? getFileSystemURL(File file)</dt>
  <dd>
    <p>This method must return a <a>FileSystem URL</a> according to the <a>URL generation steps</a> for the <a><code>File</code></a> argument.</p>
    
  </dd>
  </dl>
</section>
  </section>
  <section id="Directory">
    <h2>The Directory Interface</h2>
    <p><a><code>Directory</code></a> objects represent a <a href="#directoryConcept">directory</a> in the <a>Directory Tree</a>, and allow for API operations on that <a href="#directoryConcept">directory</a> or on other parts of the <a>Directory Tree</a>, which may affect other <a href="#directoryConcept">directories</a>. The <a>root</a> <a><code>Directory</code></a> object represents the <a>root</a> <a href="#directoryConcept">directory</a>. Each <a><code>Directory</code></a> object must refer to the <a>present working directory</a>, unless any method called on that <a><code>Directory</code></a> uses a <a>path</a> argument that refers to another <a href="#directoryConcept">directory</a> or file. </p>
    <section id="DirectoryOrigin">
      <h2>Origin of a Directory</h2>
      <p>The <a>origin</a> of a <a><code>Directory</code></a> is the same as the <a>origin</a> of the <a><code>document</code></a> or <a><code>worker</code></a>. Each <a>origin</a> has one <a><code>root</code></a> <a><code>Directory</code></a>.</p>
      <div class="note"><p>The <a>origin</a> of the <a>root</a> <a><code>Directory</code></a> is not affected by changes to <code>document.domain</code>.</p></div>
      <div class="issue"><p>Origin may be redefined in terms of Script Realm; open bugs include <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27203">27203</a>, <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27204">27204</a>, and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26603">26603</a>.</p></div>
    </section>
    <section id="DirectoryPromise">
     <h2>Resolving or Rejecting a Directory-Creating Promise</h2> 
      <p>When this specification says to <em>resolve or reject a promise p</em> according to the <dfn>Directory Creation Steps</dfn>, a conforming implementation must run the following steps within the asynchronous block that invoked this algorithm, and return control back to the invoking algorithm after resolving or rejecting <var>p</var>:</p>
      <ol>
        <li><p>If the method was invoked without a <a>path</a> argument, run the following <a><code>root</code></a> <a><code>Directory</code></a> substeps:</p>
        <ol>
          <li><p>If the <a><code>root</code></a> <a><code>Directory</code></a> cannot be returned by the implementation, resolve <var>p</var> with null.</p>
            <div class="note"><p>The invocation without a path argument occurs from <code>navigator.getFileSystem()</code>. In practice, there are few reasons for a user agent to not return a <code>root</code> <a><code>Directory</code></a> object; various errors may arise from <a><code>Directory</code></a> operations on the <a><code>root</code></a> <a><code>Directory</code></a>, but failure to create a <a><code>root</code></a> <a><code>Directory</code></a> should fulfill a Promise with <code>null</code>.</p></div>
          </li>
          <li>Otherwise, resolve <var>p</var> with the <a><code>root</code></a> <a><code>Directory</code></a>. 
          </li>
        </ol> 
        </li>
        <li><p>Otherwise the method was invoked with a <a>path</a> argument. Run the following <a><code>Directory</code></a> creation for a <a>path</a> argument steps:</p>
          <ol>
            <li><p>If the <a>path</a> argument is the empty string, then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
            <li><p>If the <a>path</a> argument is a single U+002F SOLIDUS character ("/") then resolve <var>p</var> with the <a><code>root</code></a> <a><code>Directory</code></a>.</p></li>
            <li><p>Otherwise let <var>input</var> be set to the <a>path</a> argument, and let <var>position</var> be a pointer to <var>input</var>, initially pointing to the first character of <var>input</var>. Let <var>dirname</var> initially be set to the empty string, and let <var>tokens</var> be an ordered list of tokens, initally empty. If the character at <var>position</var> is a U+002F SOLIDUS character ("/"), set the <a>Directory Pointer</a> to the <a>root</a> of the <a>Directory Tree</a>, and advance <var>position</var> by one character. If not, set the <a>Directory Pointer</a> to the <a>present working directory</a>. <a href="#strictly-split-a-string">Strictly split</a> <var>input</var> on the U+002F SOLIDUS character ("/").</p></li>
            <li><p>While there are tokens in <var>tokens</var>, set <var>dirname</var> to initially equal the first token in <var>tokens</var>, moving to the next one at each iteration, and run the following substeps:</p>
              <ol><li> If <var>dirname</var> strictly matches a <a href="#subdirectoryConcept">subdirectory</a> <a>name</a> that is the next position of the <a>Directory Pointer</a>, advance the <a>Directory Pointer</a> to the position on the <a>Directory Tree</a> that corresponds to the <a href="#directoryConcept">directory</a> named <var>dirname</var> and reset <var>dirname</var> to the empty string.</li>
              <li> If <var>dirname</var> does not strictly match the next position of the <a>Directory Pointer</a>, then <a href="#addToDirectoryTree">add to the Directory Tree</a> a <a><code>Directory</code></a> called <var>dirname</var> and advance the <a>Directory Pointer</a> to the newly created <a>Directory</a> and reset <var>dirname</var> to the empty string. If <a href="#addToDirectoryTree">adding to the Directory Tree</a> raises any error, reject <var>p</var> with the most appropriate error from the <a>Directory Promise Rejection Error Table</a>. </p></li>
            </li></ol>
            <li><p>If all values of <var>dirname</var> strictly match the <a>name</a> of nodes on the <a>Directory Tree</a>, and <em>no new directories are added</em> to the <a>Directory Tree</a>, reject <var>p</var> with an <code>InvalidModificationError</code>.</p></li>
            <li><p>Otherwise, resolve <var>p</var> with a new <a><code>Directory</code></a> <var>d</var> with the following properties:</p>
              <ul><li><code>d.name</code> is set to the last token in <var>tokens</var>; this must correspond to the last <a href="#directoryConcept">directory</a> <a href="#addToDirectoryTree">added</a> to the <a>Directory Tree</a>.</li>
                  <li><p><var>d</var> is set to be the <a>present working directory</a>.</p>
                    <div class="note"><p>Subsequent <a><code>Directory</code></a> operations on <var>d</var> that use a <a>relative path</a> will set the <a>Directory Pointer</a> to <var>d</var>. </p></div>
                  </li>
              </ul>
          </li>
        </ol>
      </li>
      </ol>
    </section>
    <section id="rejectionDirectoryPromise">
      <h2>Directory Promise Rejection Error Table</h2>
      <p>Rejection of <a><code>Directory</code></a>-creation promises occur with the errors and reasons shown in the <dfn>Directory Promise Rejection Error Table</dfn> below.</p>
        <table><thead><tr><th>Type
       </th><th>Description and Failure Reason
     </th></tr></thead><tbody><tr><td><dfn id="dfn-QuotaExceededError" title="QuotaExceededError"><code>QuotaExceededError</code></dfn>
       </td><td><p>If no storage space exists for a <a href="#directoryConcept">directory</a> creation operation.</p>

      </td></tr><tr><td><dfn id="dfn-SecurityError" title="SecurityError"><code>SecurityError</code></dfn>
       </td><td><p>If the user agent determines that the <a href="directoryConcept">directory</a> creation operation causes a security risk.</p>

      </td></tr></tbody></table>
    </section>
    <section>
      <h2>Directory WebIDL</h2>
<dl title='[Exposed=Window,Worker] interface Directory' class='idl'>
  <dt>readonly attribute DOMString name</dt>
  <dd>
    <p>On getting, this must be the <a>name</a> of the underlying <a href="#directoryConcept">directory</a>.</p>
  </dd>
  <dt>Promise&lt;File> createFile(DOMString path, CreateFileOptions options)</dt>
  <dd>
    <p>When the <code>createFile(path, options)</code> method is run, the user agents must run the steps below:</p>
    <ol>
      <li><p>Let <var>p</var> be a new promise.</p></li>
      <li><p>Run the following steps asynchronously:</p>
        <ol>
          <li><p><a href="#strictly-split-a-string">Strictly split</a> the <code>path</code> argument on the U+002F SOLIDUS character. Let n be the total number of resulting <var>tokens</var>. </p></li>
          <li><p>If <a href="#crawl-the-path-until-node-n">crawling the path until node n-1</a> for the <code>path</code> argument returns failure, reject <var>p</var> with an <code>InvalidStateError</code>.</p>
          </li>
          <li><p>If the nth token in <var>tokens</var> identifies a <a href="#directoryConcept">directory</a>, reject <var>p</var> with an 
          <code>InvalidStateError</code>.</p>
        <div class="note"><p>The <code>path</code> argument must identify a file.</p></div>
        </li>
          <li><p>Otherwise, if the nth token in <var>tokens</var> strictly matches the name of a pre-existing file at the next position of the <a>Directory Pointer</a>, run the following substeps:</p>
            <ol>
              <li><p>If the <a><code>CreateIfExistsMode</code></a> <a><code>ifExists</code></a> dictionary member of the <code>options</code> argument is "fail" then reject <var>p</var> with a <code>NoModificationAllowedError</code>.</p></li>
              <li><p>If the <a><code>CreateIfExistsMode</code></a> <a><code>ifExists</code></a> dictionary member of the <code>options</code> argument is "replace" then run the following substeps:</p>
                <ol>
                  <li><p>Let <var>f</var> be a new <code>File</code> constructed according to running the <a>File Constructor Steps</a> with the following modifications:</p>
                    <ul>
                      <li><p>Treat the <code>data</code> member of the <code>options</code> dictionary as if it was a single element in the <code>fileBits</code> <code>sequence</code>, and follow the step for that type from the <a>File Constructor Steps</a>.</p></li>
                      <li><p>Replace the <code>fileName</code> parameter with the nth token in <var>tokens</var>, and normalize it according to the <a>File Constructor Steps</a>.</p></li>
                      <li><p>Set <code>f.lastModifiedDate</code> to the current date and time represented as the number of milliseconds since the <a>Unix Epoch</a> (which is the equivalent of <code>Date.now()</code> [[!ECMAScript]]).</p></li>
                      <li><div class="issue"><p>This API gives no way to configure the <code>type</code> of a <code>File</code> since filesystems do not store the type of a file. But the File constructor steps allow developers to mint File object with a <code>type</code>.</p></div></li>
                    </ul>

                  </li>
                  <li><p><a href="#removeFromDirectoryTree">Remove the file</a> at the at the next position of the <a>Directory Pointer</a> which strictly matches the name of the nth token in <var>tokens</var>.</p></li>
                  <li><p><a href="#addToDirectoryTree">Add the file</a> represented by <var>f</var> to the next position of the <a>Directory Pointer</a> and advance the <a>Directory Pointer</a> to point to <var>f</var>. If <a href="#addToDirectoryTree">adding to the Directory Tree</a> raises any error, reject <var>p</var> with the most appropriate error from the <a>Directory Promise Rejection Error Table</a>.</p></li>
                  <li><p>Otherwise, resolve <var>p</var> with <var>f</var>.</p></li>
                  
                </ol>
              </li>
            </ol>
          </li>
          <li><p>If the nth token does not strictly match the name of a pre-existing file at the next position of the <a>Directory Pointer</a> run the following substeps:</p>
                <ol>
                  <li><p>Let <var>f</var> be a new <code>File</code> constructed according to the <a>File Constructor Steps</a> with the following modifications:</p>
                    <ul>
                      <li><p>Treat the <code>data</code> member of the <code>options</code> dictionary as if it was a single element in the <code>fileBits</code> <code>sequence</code>, and follow the step for that type from the <a>File Constructor Steps</a>.</p></li>
                      <li><p>Replace the <code>fileName</code> parameter with the nth token in <var>tokens</var>, and normalize it according to the <a>File Constructor Steps</a>.</p></li>
                      <li><p>Set <code>f.lastModifiedDate</code> to the current date and time represented as the number of milliseconds since the <a>Unix Epoch</a> (which is the equivalent of <code>Date.now()</code> [[!ECMAScript]).</p></li>
                      <li><div class="issue"><p>This API gives no way to configure the <code>type</code> of a <code>File</code> since filesystems do not store the type of a file. But the File constructor steps allow developers to mint File object with a <code>type</code>.</p></div></li>

                    </ul>
                  </li>
                  <li><p><a href="#addToDirectoryTree">Add the file</a> represented by <var>f</var> to the next position of the <a>Directory Pointer</a> and advance the <a>Directory Pointer</a> to point to <var>f</var>. If <a href="#addToDirectoryTree">adding to the Directory Tree</a> raises any error, reject <var>p</var> with the most appropriate error from the <a>Directory Promise Rejection Error Table</a></p>.
                 <div class="issue"><p>Rejection in this algorithm occurs at a later stage than may be desirable; "short-circuiting" this might be good.</p></div>   
                  </li>
                  <li><p>Otherwise, resolve <var>p</var> with <var>f</var>.</p></li>
                  
                </ol>                

            </li>
          </ol>
        </li>
        <li><p>Return <var>p</var></p></li>
      </ol>

  </dd>
  <dt>Promise&lt;Directory> createDirectory(DOMString path)</dt>
  <dd>
    <p>When the <code>createDirectory(path)</code> method is called, the user agent must run the steps below:</p>
    <ol>
      <li>Let <var>p</var> be a new promise and run the next step asynchronously.</li>
      <li>Resolve or reject <var>p</var> according to the <a>Directory Creation Steps</a>, using the <a>path</a> argument.</li>
      <li>Return <var>p</var></li>
    </ol>
    <dl class="parameters">
      <dt>DOMString path</dt>
      <dd>This parameter represents the <a>path</a>; user agents must interpret it as a <a>path from root</a> or a <a>relative path</a>.</dd>
    </dl>
   
  </dd>
  <dt>Promise&lt;(File or Directory)> get(DOMString path)</dt>
  <dd>
    <p>When the <code>get(path)</code> method is called, the user agent must run the steps below:</p>
    <ol>
      <li><p>Let <var>p</var> be a new promise.</p></li>
      <li><p>Run the following steps asynchronously:</p>
        <ol>
          <li><p>If <a href="#crawl-the-entire-path">crawling the entire path</a> represented by the <code>path</code> argument returns failure, reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
          <li><p>Otherwise, set <var>d</var> to the node at the position the <a>Directory Pointer</a> is pointing to, and run the following substeps:</p>
            <ol>
              <li><p>If <var>d</var> is a file, resolve <var>p</var> with a new <code>File</code> representing <var>d</var>.</p></li>
              <li><p>If <var>d</var> is a <a href="#directoryConcept">directory</a>, resolve <var>p</var> with a new <a><code>Directory</code></a> representing <var>d</var>.</p></li>
            </ol>

          </li>
        </ol>


      </li>
      <li><p>Return <var>p</var>.</p></li>
    </ol>
  </dd>
  <dt>CancelablePromise&lt;void>
    move((DOMString or File or Directory) path,
         (DOMString or Directory or DestinationDict) dest)</dt>
  <dd>
    
    <p>When the <code>move(path, dest)</code> method is called, the user agent must run the steps below:</p>
    <ol>
      <li><p>Let <var>p</var> be a new CancelablePromise.</p>
      <div class="issue"><p>The web does not have a <code>CancelablePromise</code> type yet.</p></div>  
      </li>
      <li><p>Run the following steps asynchronously:</p>
        <ol>
          <li><p>If <code>path</code> is a <code>DOMString</code>, then <a href="#crawl-the-entire-path">crawl the entire path</a> represented by <code>path</code>. If it returns failure, then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
          <li><p>If <code>dest</code> is a <code>DOMString</code>, then run the following substeps:</p>
            <ol>
              <li><a href="#crawl-the-entire-path">Crawl the entire path</a> represented by <code>dest</code> as a <a>path</a>. If it returns failure, then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
              <li>If the <a>path</a> represented by <code>dest</code> is a <code>File</code>, reject <var>p</var> with an <code>InvalidStateError</code>.</p>
              <div class="note"><p>It is an error to move a <a href="#directoryConcept">directory</a> or a file to the location of another file; <code>dest</code> must represent a <a href="#directoryConcept">directory</a>, either through a valid <a>path</a> string, a <a><code>Directory</code></a> object, or the <a><code>DestinationDict</code></a> dictionary argument.</p></div>
              </li>
            </ol>
          </li>
          <li><p>If the node that corresponds to <code>dest</code> is a <a>child</a> of <code>path</code>, then reject <var>p</var> with an 
            <code>InvalidStateError</code>.</p>
          <div class="note"><p>This is an <a href="#illegal">illegal transfer</a>.</p></div>
          </li>
          <li><p>If <code>path</code> and <code>dest</code> both represent <a href="#directoryConcept">directories</a> and are at the identical position on the <a>Directory Tree</a>, run the following substeps:</p>
            <ol>
              <li><p>If <code>dest</code> is not a <a><code>DestinationDict</code></a> with a <code>name</code> member that has a value different than the <a>name</a> of the <a href="#directoryConcept">directory</a> represented by <code>path</code>, then reject <var>p</var> with an <code>InvalidStateError</code>.</p>
              <div class="note"><p>This is an <a href="#illegal">illegal transfer</a>; only a <a><code>DestinationDict</code></a> allows for a <a href="#renamingOperation">renaming operation</a>.</p></div>
              </li>
              <li><p>Otherwise:</p><ol><li><p>if <code>dest</code> is a <a><code>DestinationDict</code></a> with a <code>name</code> member that has a value different than the <a>name</a> of the <a href="#directoryConcept">directory</a> represented by <code>path</code>, conduct a <a href="#renamingOperation">renaming operation</a> on the <a href="#directoryConcept">directory</a> identified by <code>path</code></p></li><li><p>resolve <var>p</var> with <em>undefined</em>.</p></li></ol>
              <div class="note"><p>This may have implications for <a><code>Directory</code></a> objects that exist with the old name of the underlying <a href="#directoryConcept">directory</a>.</p></div>
              </li>
            </ol>
          </li>
          <li><p>If <code>path</code> is a <a>child</a> of <code>dest</code> and <code>dest</code> has an <a>immediate child</a> which is a <a>parent</a> of <code>path</code> with the same <a>name</a> as the node identified by <code>path</code>, then reject <var>p</var> with an <a><code>InvalidStateError</code></a>.</p>
          <div class="note"><p>This is an <a href="#illegal">illegal transfer</a>.</p></div>
          </li>
          <li><p>Otherwise:</p><ol><li><p><a href="#transfer">transfer</a> <code>path</code> to <code>dest</code>. If there were errors in the transfer, reject <var>p</var> with the most appropriate error from the <a>Directory Promise Rejection Error Table</a>.</p></li><li><p>If there were no errors, resolve <var>p</var> with <em>undefined</em>.</p></li></ol></li>

        </ol>
        <li><p>Return <var>p</var>.</p></li>
    </ol>
  </dd>
  <dt>Promise&lt;boolean> remove((DOMString or File or Directory) path)</dt>
  <dd>
    <p>When the <code>remove(path)</code> method is called, the user agent must run the steps below:</p>
    <div class="issue"><p>Is it better to take advantage of boolean semantics and ONLY resolve this promise with true or false (never reject) or to reject this promise, like other Directory operation promises get rejected? #bikeshed?</p></div>
    <ol>
      <li><p>Let <var>p</var> be a new promise.</p></li>
      <li><p>Run the following steps asynchronously:</p>
        <ol>
          <li><p>If <code>path</code> is a <code>DOMString</code> <a href="#crawl-the-entire-path">crawl the entire path</a>. If it returns failure, resolve <var>p</var> with <code>false</code>.</p></li>
          <li><p>If <code>path</code> is a <code>File</code> then run the following substeps:</p>
            <ol>
              <li>
                <p><a href="#removeFromDirectoryTree">Remove from the Directory Tree</a> the node identified by the <code>path</code> argument.</p>
                <div class="issue"><p>Error conditions could arise with removal. This should generate a fulfillment with <code>false</code>.</p></div>
              </li>
              <li><p>Resolve <var>p</var> with <code>true</code>.</p></li>
            </ol>
            <div class="issue"><p>This has implications for existing <code>File</code> object references. The "lock" problem needs to be solved.</p></div>
          </li>
          <li><p>If <code>path</code> represents a <a href="#directoryConcept">directory</a> run the following substeps:</p>
            <ol>
              <li><p>If <code>path</code> has one or more <a>child</a> nodes, resolve <var>p</var> with <code>false</code>.</p></li>
              <li><p>Otherwise, run the following substeps:</p>
              <ol>
              <li>
                <p><a href="#removeFromDirectoryTree">Remove from the Directory Tree</a> the node identified by the <code>path</code> argument.</p>
                <div class="issue"><p>This has implications for existing <code>Directory</code> object references. The "lock" problem needs to be solved.</p>
                  <p>Error conditions could arise with removal. This should generate a fulfillment with <code>false</code>.</p>
                </div>
              </li>
              <li><p>Resolve <var>p</var> with <code>true</code>.</p></li>
            </ol>
           </li>
         </ol>
        </li>
        </ol>
      </li>
      <li>Return <var>p</var>.</li>
    </ol>
  </dd>
  <dt>Promise&lt;boolean> removeDeep((DOMString or File or Directory) path)</dt>
  <dd>
    <p>When the <code>removeDeep(path)</code> method is called, the user agent must run the steps below:</p>
    <div class="issue"><p>Is it better to take advantage of boolean semantics and ONLY resolve this promise with true or false (never reject) or to reject this promise, like other Directory operation promises get rejected? #bikeshed?</p></div>
    <ol>
      <li><p>Let <var>p</var> be a new promise.</p></li>
      <li><p>Run the following steps asynchronously:</p>
        <ol>
          <li><p>If <code>path</code> is a <code>DOMString</code> <a href="#crawl-the-entire-path">crawl the entire path</a>. If it returns failure, resolve <var>p</var> with <code>false</code>.</p></li>
          <li><p>If <code>path</code> is a <code>File</code> then run the following substeps:</p>
            <ol>
              <li>
                <p><a href="#removeFromDirectoryTree">Remove from the Directory Tree</a> the node identified by the <code>path</code> argument.</p>
              </li>
              <li><p>Resolve <var>p</var> with <code>true</code>.</p></li>
            </ol>
            <div class="issue"><p>This has implications for existing <code>File</code> object references. The "lock" problem needs to be solved.</p></div>
          </li>
          <li><p>If <code>path</code> represents a <a href="#directoryConcept">directory</a> run the following substeps:</p>
            <ol>
              <li><p>If <code>path</code> has no <a>child</a> nodes, run the following substeps:</p>
                <ol>
                  <li><a href="#removeFromDirectoryTree">remove from the Directory Tree</a> the node identifed by the <code>path</code> argument.
                    <div class="issue"><p>Error conditions could arise with removal. This should generate a fulfillment with <code>false</code>.</p></div>
                  </li>
                  <li>Resolve <var>p</var> with <code>true</code></li>
                </ol>
              </li>
              <li><p>If <code>path</code> has one or more <a>child</a> nodes, run the following substeps:</p>
              <ol>
              <li>
                <p>Recursively <a href="#removeFromDirectoryTree">remove from the Directory Tree</a> the node identified by the <code>path</code> argument, including all <a>child</a> nodes.</p>
                <div class="issue"><p>This has implications for existing <code>Directory</code> object references, for both the <a>present working directory</a> and all <a>child</a> nodes. The "lock" problem needs to be solved.</p><p>Error conditions could arise with removal. This should generate a fulfillment with <code>false</code>.</p></div>
              </li>
              <li><p>Resolve <var>p</var> with <code>true</code>.</p></li>
            </ol>
           </li>
         </ol>
        </li>
        </ol>
      </li>
      <li>Return <var>p</var>.</li>
    </ol>
  </dd>
  <dt>Promise&lt;FileHandle> openRead((DOMString or File) path)</dt>
  <dd>
    <p>When the <code>openRead(path)</code> method is called, the user agent must run the steps below:</p>
  <ol>
    <li>Let <var>p</var> be a new promise.</li>
    <li><p>Run the following steps asynchronously:</p>
      <ol>
        <li><p>If <code>path</code> is a <code>DOMString</code>, run the following substeps:</p>
          <ol>
            <li><a href="#crawl-the-entire-path">Crawl the entire path.</a> If it returns failure, then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
            <li>If <code>path</code> represents a <a href="#directoryConcept">directory</a> node and not a file node, reject <var>p</var> with an <code>InvalidStateError</code>.
            </li>
          <li><p>Otherwise, resolve <var>p</var> with a new <code>FileHandle</code> set to refer to the file at <code>path</code>.</p></li>  
        </ol>
        </li>
        <li>Return <var>p</var>.</li>


      </ol>

  </ol>
  </dd>
  <dt>Promise&lt;FileHandleWritable> openWrite((DOMString or File) path,
        OpenWriteOptions options)</dt>
    <dd>
    <p>When the <code>openWrite(path, options)</code> method is called, the user agent must run the steps below:</p>
    <ol>
      <li>Let <var>p</var> be a new promise, and <var>filename</var> a string, initially empty.</li>
      <li><p>Run the following steps asynchronously:</p>
      <ol>
      <li><p>If the <code>path</code> argument is a DOMString, then run the substeps below:</p>
        <ol>
          <li><p><a href="#strictly-split-a-string">Strictly split</a> the <code>path</code> argument on the U+002F SOLIDUS character. Let <var>n</var> be the total number of resulting <var>tokens</var>. </p></li>
          <li><p>If <a href="#crawl-the-path-until-node-n">crawling the path until node n-1</a> for the <code>path</code> argument returns failure, reject <var>p</var> with an <code>InvalidStateError</code>.</p>
          </li>
          <li><p>If the node identified by the token at <var>n</var> is a <a href="#directoryConcept">directory</a>, reject <var>p</var> with an <code>InvalidStateError</code>.</p>
          <div class="note"><p>If a DOMString is used for <code>path</code>, it must point to a file in the <a>Directory Tree</a>, or be a the name of a potential new file.</p></div>
          </li> 
          <li>Otherwise, set <var>filename</var> to the <var>n</var>th token.</li>
         
        </ol>
      </li>
       <li><p>If <code>path</code> is a <a><code>File</code></a> then set <var>filename</var> to <code>path.name</code>.</p></li> 
       <li><p>If <code>path</code> is a <a><code>File</code></a> and <var>filename</var> corresponds to an existing file's name in the <a>present working directory</a> OR path is a DOMString and <var>filename</var> corresponds to a file's name in the <a href="#directoryConcept">directory</a> identified by the <var>n-1</var>th token, then run the following substeps: </p>
      <div class="note"><p>If path is a <a><code>File</code></a>, then this method applies to the <a>present working directory</a>; if <a>path</a> is a DOMString, then this method applies to the <a href="#directoryConcept">directory</a> identified by <a>path</a>'s <var>n-1</var>th token.</p></div>
      <ol>
        <li><p>If the optional <a><code>OpenWriteOptions</code></a> dictionary argument is used, and the <a><code>OpenIfExistsMode</code></a> <a><code>ifExists</code></a> member is "fail" then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
        <li><p>Otherwise, if the <a><code>OpenIfExistsMode</code></a> <a><code>ifExists</code></a> dictionary member is "open" then run the substeps below:</p>
        <div class="note"><p>This enum value is set to "open" by default.</p></div>
          <ol>
            <li><p>If the <a><code>Flush</code></a> dictionary member is set to <code>true</code>, resolve <var>p</var> with a <a>flushing</a> <a><code>FileHandleWritable</code></a> object set to the file corresponding to <code>path</code>. </p>  
            </li>
            <li><p>If the <a><code>Flush</code></a> dictionary member is set to <code>false</code>, resolve <var>p</var> with a <a>non-flushing</a> <a><code>FileHandleWritable</code></a> object set to the file corresponding to <code>path</code>. </p>
            <div class="note"><p>This value is set to <code>false</code> by default.</p></div>  
            </li>

          </ol>
        </li>
        <li><p>Otherwise, if <code>path</code> is a <a><code>File</code></a> and <var>filename</var> does NOT correspond to an existing file's name in the <a>present working directory</a> OR <code>path</code> is a DOMString and <var>filename</var> does NOT correspond to a file's name in the <a href="#directoryConcept">directory</a> identified by the <var>n-1</var>th token, then run the following substeps: </p>
        <ol>
          <li><p>If the optional <a><code>OpenWriteOptions</code></a> dictionary argument is used, and the <a><code>OpenIfNotExistsMode</code></a> <a><code>ifNotExists</code></a> member is "fail" then reject <var>p</var> with an <code>InvalidStateError</code>.</p></li>
          <li><p>Otherwise, if the <a><code>OpenIfNotExistsMode</code></a> <a><code>ifNotExists</code></a> dictionary member is "create" then run the substeps below: 
          </p>
          <div class="note"><p>This enum value is set to "create" by default.</p></div>
             <ol>
            <li><p>If the <a><code>Flush</code></a> dictionary member is set to <code>true</code>, resolve <var>p</var> with a <a>flushing</a> <a><code>FileHandleWritable</code></a> object set to the file corresponding to <code>path</code>. </p>  
            </li>
            <li><p>If the <a><code>Flush</code></a> dictionary member is set to <code>false</code>, resolve <var>p</var> with a <a>non-flushing</a> <a><code>FileHandleWritable</code></a> object set to the file corresponding to <code>path</code>. </p>
            <div class="note"><p>This value is set to <code>false</code> by default.</p></div>  
            </li>

          </ol>

          </li>

        </ol>

        </li>
      </ol>

       </li>
        </ol>

      </li>
    </li>
    <li>Return <var>p</var></li>
    </ol>
  </dd>
  <dt>Observable&lt;(File or Directory)> enumerate(optional DOMString path)</dt>
  <dd>
    <div class="issue"><p>The <code>Observable</code> async generator and semantics around it are not well-defined yet. This is a general platform problem; <code>Observable</code> currently is a proposal within TC-39, and this should be considered "placeholder" semantics till the proposal becomes a language formalism.</p>
    </div>
    <p>When the <code>enumerate(path)</code> method is called, the user agent must run the steps below:</p>
     <ol>
        <li>If no parameter is provided, set the <a>Directory Pointer</a> to the <a>present working directory</a>. For each <a>immediate child</a>, emit a corresponding object (<a><code>File</code></a> or <a><code>Directory</code></a>) until done; when done, invoke this <code>Observable</code>'s final state.</p>
        <div class="note"><p>If there are no <a>immediate child</a> nodes, this becomes the empty <code>Observable</code>.</p></div>  
        </li>
        <li>If a parameter is provided, and <a href="#crawl-the-entire-path">crawling the entire path</a> returns failure, invoke the <code>Observable</code>'s rejection path with an <code>InvalidStateError</code>.</li>
        <li>If <a href="#crawl-the-entire-path">crawling the entire path</a> does not return failure, run the substeps below:
          <ol>
            <li>If the <a>Directory Pointer</a> points to a file, emit a <a><code>File</code></a> corresponding to the file; when done, invoke this <code>Observable</code>'s final state.</li>
            <li>If the <a>Directory Pointer</a> points to a <a href="#directoryConcept">directory</a>, for each <a>immediate child</a>, emit a corresponding object (<a><code>File</code></a> or <a><code>Directory</code></a>) until done; when done, invoke this <code>Observable</code>'s final state.</li>
          </ol>
        </li>
      </ol>
  </dd>
  <dt>Observable&lt;(File)> enumerateDeep(optional DOMString path)</dt>
  <dd>
    <div class="issue"><p>The <code>Observable</code> async generator and semantics around it are not well-defined yet. This is a general platform problem; <code>Observable</code> currently is a proposal within TC-39, and this should be considered "placeholder" semantics till the proposal becomes a language formalism.</p>
    </div>
      <p>When the <code>enumerateDeep(path)</code> method is called, the user agent must run the steps below:</p>
      <ol>
        <li>If no parameter is provided, set the <a>Directory Pointer</a> to the <a>present working directory</a> and run the following substeps:
         <ol>
         <li><p>If there are <a>immediate child</a> nodes and they are files, emit a corresponding <a><code>File</code></a> object.</p>
          <div class="note"><p>If there are no <a>immediate child</a> nodes, this becomes the empty <code>Observable</code>.</p></div>
         </li> 
         <li><p>If any <a>immediate child</a> is a <a href="#directoryConcept">directory</a>, run the following substeps for all <a>child</a> nodes of that <a href="#directoryConcept">directory</a>:
          <ol><li>Set the <a>Directory Pointer</a> to the <a href="#directoryConcept">directory</a> and emit a corresponding <a><code>File</code></a> object for any <a>immediate child</a> nodes that are files.</p></li>
            <li>If any <a>immediate child</a> nodes are <a href="#directoryConcept">directories</a>, run the step above on them.</li>
          
        </ol>
      </li>
      <li><p>When done, invoke this <code>Observable</code>'s final state.</p></li>
    </ol>
  </li>
        <li><p>If a parameter is provided, and <a href="#crawl-the-entire-path">crawling the entire path</a> returns failure, invoke the <code>Observable</code>'s rejection path with an <code>InvalidStateError</code>.</p></li>
        <li><p>If <a href="#crawl-the-entire-path">crawling the entire path</a> above does not return failure, run the substeps below:</p>
          <ol>
            <li><p>If the <a>Directory Pointer</a> points to a file, emit a <a><code>File</code></a> corresponding to the file; when done, invoke this <code>Observable</code>'s final state.</p></li>
            <li>If the <a>Directory Pointer</a> points to a <a href="#directoryConcept">directory</a>, run the following substeps:
          <ol>
          <li><p>If there are <a>immediate child</a> nodes and they are files, emit a corresponding <a><code>File</code></a> object.</p>
          <div class="note"><p>If there are no <a>immediate child</a> nodes, this becomes the empty <code>Observable</code>.</p></div>
         </li> 
         <li><p>If any <a>immediate child</a> is a <a href="#directoryConcept">directory</a>, run the following substeps for all <a>child</a> nodes of that <a href="#directoryConcept">directory</a>:
          <ol><li>Set the <a>Directory Pointer</a> to the <a href="#directoryConcept">directory</a> and emit a corresponding <a><code>File</code></a> object for any <a>immediate child</a> nodes that are files.</p></li>
            <li>If any <a>immediate child</a> nodes are <a href="#directoryConcept">directories</a>, run the step above on them.</li></ol>
            
      </li>
      <li><p>When done, invoke this <code>Observable</code>'s final state.</p></li>
          </ol>
        </li>
      </ol>
  </dd>
  
</dl>
</section>
  </section>
  <section>
    <h2>The FileHandle interface</h2>
    <section>
      <h2>FileHandle WebIDL</h2>
  <dl title='interface FileHandle' class='idl'>
   <dt>readonly attribute FileOpenMode mode</dt>
   <dd>
    <p>TBD</p>
  </dd>
  <dt>readonly attribute boolean active</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>attribute long long? offset</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>Promise&lt;File> getFile()</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>CancelablePromise&lt;ArrayBuffer> read(unsigned long long size) </dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>void cancel()</dt>
  <dd>
    <p>TBD</p>
  </dd>
    </dl>
  </section>
</section>
<section>
<h2>The FileHandleWritable Interface</h2>
<section>
  <h2>FileHandleWritable WebIDL</h2>
 <dl title='interface FileHandleWritable : FileHandle' class='idl'>
<dt>CancelablePromise&lt;void> write((DOMString or ArrayBuffer or
ArrayBufferView or Blob) value)</dt>
<dd>
  
    <p>TBD</p>
  </dd>
 <dt>Promise&lt;void> setSize(optional unsigned long long size)</dt>
 <dd>
    <p>TBD</p>
  </dd>
</dl>  
</section>
</section>
<section>
<h2>FileSystem Configuration Parameters</h2>
<dl title="dictionary CreateFileOptions" class="idl">
  <dt>CreateIfExistsMode ifExists = "fail"</dt>
   <dd>
    <p>This enum value indicates whether to write over a pre-existing file or to fail the attempt to write over a pre-existing file.</p>
  </dd>
  <dt>(DOMString or Blob or ArrayBuffer or ArrayBufferView) data</dt>
    <dd><p></p></dd>
</dl>
<dl title="dictionary OpenWriteOptions" class="idl">
 <dt>OpenIfNotExistsMode ifNotExists = "create"</dt>
 <dd>
    <p>TBD</p>
  </dd>
  <dt>OpenIfExistsMode ifExists = "open"</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>boolean Flush = false</dt>
  <dd>
    <p>TBD</p>
  </dd>
</dl>

<dl title="enum CreateIfExistsMode" class="idl">
<dt>replace</dt>
<dd>
    <p>This value, if set, replaces a <a><code>File</code></a> by removing it and writing a new <a><code>File</code></a> over it.</p>
  </dd>
<dt>fail</dt>
<dd>
    <p>This is the default; by default, a file cannot be replaced.</p>
  </dd>  
</dl>
<dl title="enum OpenIfExistsMode" class="idl">
  <dt>open</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>fail</dt>
  <dd>
    <p>TBD</p>
  </dd>
</dl>
<dl title="enum OpenIfNotExistsMode" class="idl">
  <dt>create</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>fail</dt>
  <dd>
    <p>TBD</p>
  </dd>
</dl>

<dl title="dictionary DestinationDict" class="idl">
  <dt>Directory dir</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>DOMString name</dt>
  <dd>
    <p>TBD</p>
  </dd>
</dl>

<dl title="enum FileOpenMode" class="idl">
  <dt>readonly</dt>
  <dd>
    <p>TBD</p>
  </dd>
  <dt>readwrite</dt>
  <dd>
    <p>TBD</p>
  </dd>
</dl>
</section>
<section>
<h2>FileSystem URLs</h2>
<p></p>
</section>
<section>
  <h2>Acknowledgements</h2>
  Jonas Sicking, Mounir Lamouri, Ben Turner, Jan Varga, Andrea Marchesini, Doug Turner, Maciej Stachowiak
</section>
   
  </body>
</html>
